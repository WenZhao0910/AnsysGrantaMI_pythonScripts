{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "1ae54d5a-3e67-4d75-8f82-25e969184909",
   "metadata": {},
   "source": [
    "# Compare test data to specification values\n",
    "\n",
    "The following script demonstrates how to compare raw test data to specification values that define acceptable ranges for the test data. In this example, the specification values are stored in a separate record that is linked to the test data."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1db9526b-390f-4b05-af77-de12dc4d0f76",
   "metadata": {},
   "source": [
    "## Connect to Granta MI\n",
    "\n",
    "Connect to Granta MI and specify the database and table containing the test results.\n",
    "\n",
    "Since this operation is likely to be performed as a batch operation, see the notebook on [Storing Credentials Securely](../streamlined/22_Storing_credentials_securely.ipynb) for more information how to connect to Granta MI securely in a batch Python script."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "fe8455c2-2909-4241-8284-fe138a3e71f0",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-05-10T23:01:31.992998Z",
     "iopub.status.busy": "2022-05-10T23:01:31.992998Z",
     "iopub.status.idle": "2022-05-10T23:01:35.808699Z",
     "shell.execute_reply": "2022-05-10T23:01:35.808699Z"
    },
    "tags": []
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<Table name: Tensile Test Data, subsets: set()>"
      ]
     },
     "execution_count": 1,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "from GRANTA_MIScriptingToolkit import granta as mpy\n",
    "\n",
    "s = mpy.Session('localhost', autologon=True)\n",
    "db = s.get_db('MI Training')\n",
    "test_data_table = db.get_table('Tensile Test Data')\n",
    "test_data_table"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f63afe73-cd0a-4c0a-a4ee-c1a800091e4d",
   "metadata": {},
   "source": [
    "## Find test data to process"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c1ee343a-6f3d-43a5-890b-23a491449e6c",
   "metadata": {},
   "source": [
    "Before we start, we need to find the **Test Data** records we want to process by applying the following criteria:\n",
    "1. The test record has test data which has not previously been compared to a specification.\n",
    "2. The test record is linked to a specification record."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cf66f763-5631-4f10-a284-bfac6dd06826",
   "metadata": {},
   "source": [
    "### Criteria 1: Test data that has not been compared to a specification"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "80e9277d-e6a1-418f-86df-ac8b4dd72c4b",
   "metadata": {},
   "source": [
    "First, define the attributes that contain the relevant test data, and the name of the meta-attribute that contains specification comparison results (if they exist).\n",
    "A dictionary is used for test data attributes so they can be mapped to the corresponding specification attributes."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "bc02d504-df6c-4b24-bcac-c8769ca505f9",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-05-10T23:01:35.808699Z",
     "iopub.status.busy": "2022-05-10T23:01:35.808699Z",
     "iopub.status.idle": "2022-05-10T23:01:35.818701Z",
     "shell.execute_reply": "2022-05-10T23:01:35.818701Z"
    }
   },
   "outputs": [],
   "source": [
    "COMPARISON_ATTRIBUTES = {'0.02% Offset yield stress (specification value)': '0.02% Offset Yield Stress',\n",
    "                         '0.2% Offset yield stress (specification value)': '0.2% Offset Yield Stress',\n",
    "                         'Tensile modulus (specification value)': \"Young's Modulus (11-axis)\",\n",
    "                         'Ultimate tensile strength (specification value)': \"Ultimate Tensile Strength\",\n",
    "                         }\n",
    "SPEC_STATUS_META_ATTRIBUTE = 'Specification status'"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "aa9ee57d-bb96-4cab-a440-fd198b71f675",
   "metadata": {},
   "source": [
    "Next, define an _unprocessed records_ function that takes an attribute name as input and returns the list of records where the attribute is populated, but the meta-attribute is empty."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "7fb83c4a-0609-4b72-8723-bbae331d157c",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-05-10T23:01:35.818701Z",
     "iopub.status.busy": "2022-05-10T23:01:35.818701Z",
     "iopub.status.idle": "2022-05-10T23:01:35.828700Z",
     "shell.execute_reply": "2022-05-10T23:01:35.828700Z"
    }
   },
   "outputs": [],
   "source": [
    "from typing import List\n",
    "\n",
    "def find_unprocessed_records_for_attribute(test_attribute_name: str) -> List[mpy.Record]:\n",
    "    test_attribute_definition = test_data_table.attributes[test_attribute_name]\n",
    "    spec_result_attribute_definition = test_attribute_definition.meta_attributes[SPEC_STATUS_META_ATTRIBUTE]\n",
    "\n",
    "    test_result_attribute_has_value = test_attribute_definition.search_criterion(exists=True)\n",
    "    spec_comparison_result_is_empty = spec_result_attribute_definition.search_criterion(exists=False)\n",
    "\n",
    "    unprocessed_records = test_data_table.search_for_records_where([test_result_attribute_has_value, spec_comparison_result_is_empty])\n",
    "    return unprocessed_records"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d8c595bb-bc9b-43d8-a04c-01b12f95c716",
   "metadata": {},
   "source": [
    "Iterate over each attribute defined in the `ATTRIBUTES` constant to get the previously unprocessed records for each one. Use a dictionary with the `record.id` as the key to ensure you only get unique records (a single record may be missing multiple attributes, and we only want to process each record once)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "b329b9bc-2444-468f-88d3-c2d202959c53",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-05-10T23:01:35.828700Z",
     "iopub.status.busy": "2022-05-10T23:01:35.828700Z",
     "iopub.status.idle": "2022-05-10T23:01:46.686416Z",
     "shell.execute_reply": "2022-05-10T23:01:46.686416Z"
    }
   },
   "outputs": [],
   "source": [
    "unique_unprocessed_records = {}\n",
    "\n",
    "for test_attribute in COMPARISON_ATTRIBUTES.values():\n",
    "    unprocessed_records_for_attribute = find_unprocessed_records_for_attribute(test_attribute)\n",
    "    unique_unprocessed_records.update({r.id: r for r in unprocessed_records_for_attribute})"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e896f381-9d67-48bf-8825-d8b89ccaaa2c",
   "metadata": {},
   "source": [
    "Finally, extract the `record` values from the `dict` and confirm the number of unprocessed records identified."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "6de5ec34-a520-49b4-8a36-88650dd66054",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-05-10T23:01:46.686416Z",
     "iopub.status.busy": "2022-05-10T23:01:46.686416Z",
     "iopub.status.idle": "2022-05-10T23:01:46.696419Z",
     "shell.execute_reply": "2022-05-10T23:01:46.696419Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "176 unprocessed records.\n"
     ]
    }
   ],
   "source": [
    "unprocessed_records = list(unique_unprocessed_records.values())\n",
    "print(f\"{len(unprocessed_records)} unprocessed records.\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "5cfc60e2-850c-4eb6-af73-2a06b37fd136",
   "metadata": {},
   "source": [
    "### Criteria 2: Test data with linked specifications"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "8a585a26-bc5a-418c-9c8f-4f2607ba61ac",
   "metadata": {},
   "source": [
    "To compare test data to specification values, each unprocessed record must also be linked to a specification record containing those values. Therefore, we need to filter the `unprocessed_records` list to include only those records that have a link to a **Specification Values** record.\n",
    "\n",
    "Use the `test_data_table.bulk_link_fetch()` method to improve performance by fetching links for all records in a single operation. The link group name is stored in a constant, since we will need to refer to it later."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "8a4e8ece-2478-41e8-8294-092d0e4248bc",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-05-10T23:01:46.696419Z",
     "iopub.status.busy": "2022-05-10T23:01:46.696419Z",
     "iopub.status.idle": "2022-05-10T23:01:50.354378Z",
     "shell.execute_reply": "2022-05-10T23:01:50.354378Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "6 unprocessed records with links to specifications.\n"
     ]
    }
   ],
   "source": [
    "SPEC_LINK_GROUP_NAME = 'Specification Values'\n",
    "\n",
    "test_data_table.bulk_link_fetch(link_groups=[SPEC_LINK_GROUP_NAME], records=unprocessed_records)\n",
    "records_to_process = [r for r in unprocessed_records if r.links[SPEC_LINK_GROUP_NAME]]\n",
    "print(f\"{len(records_to_process)} unprocessed records with links to specifications.\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f4d38fb2-7859-40f6-ae72-f592b32d2a8d",
   "metadata": {},
   "source": [
    "## Compare test data to specification values"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "249ad0ee-baef-44c3-904f-3a6c76516eff",
   "metadata": {},
   "source": [
    "Now check each record in the `records_to_process` list against its linked specification."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "bbbbd361-8534-49f6-8423-e37e8458a113",
   "metadata": {},
   "source": [
    "### Pre-fetch the data"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c74024c1-d189-49d5-a966-8b8052eedbfe",
   "metadata": {},
   "source": [
    "First, pre-fetch all the attributes in the *Specification Values* and *Tensile Test Data* tables that are required for the analysis. (This step is optional, but helps improve performance for large datasets.)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "bf5fe0a7-11be-4f86-9239-ecfea8c8c913",
   "metadata": {},
   "source": [
    "Pre-fetching data using the `bulk_fetch()` operation generally requires three types of objects: a list of attributes, a list of records, and the table to fetch the data from."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "04e5b334-d0a7-4408-aa62-a3188ca8ad37",
   "metadata": {},
   "source": [
    "For the test data, we already have the `test_data_table` object and the list of records. However, we need to construct the list of attributes. We want to export the following:\n",
    "- The *Specimen ID* attribute, used for printing status information while performing the comparison\n",
    "- The list of test data attributes defined as values in the `COMPARISON_ATTRIBUTES` dictionary\n",
    "- The *Specification Status* meta-attribute\n",
    "\n",
    "The cell below builds this list of attributes, and then uses `bulk_fetch()` to fetch the data."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "7dc66ddd-70c8-42eb-a8f6-f71acc4374ba",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-05-10T23:01:50.354378Z",
     "iopub.status.busy": "2022-05-10T23:01:50.354378Z",
     "iopub.status.idle": "2022-05-10T23:01:50.721920Z",
     "shell.execute_reply": "2022-05-10T23:01:50.721920Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Bulk fetched 9 attributes across 6 records\n"
     ]
    }
   ],
   "source": [
    "SPECIMEN_ID_ATTRIBUTE = 'Specimen ID'\n",
    "specimen_id_attribute_object = test_data_table.attributes[SPECIMEN_ID_ATTRIBUTE]\n",
    "test_data_attributes = [specimen_id_attribute_object]\n",
    "\n",
    "for attribute_name in COMPARISON_ATTRIBUTES.values():\n",
    "    attribute = test_data_table.attributes[attribute_name]\n",
    "    meta_attribute = attribute.meta_attributes[SPEC_STATUS_META_ATTRIBUTE]\n",
    "    test_data_attributes.extend([attribute, meta_attribute])\n",
    "    \n",
    "test_data_table.bulk_fetch(records=records_to_process, attributes=test_data_attributes)\n",
    "print(f\"Bulk fetched {len(test_data_attributes)} attributes across {len(records_to_process)} records\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ef782cf2-1b76-409c-931d-73bb24da6a5d",
   "metadata": {},
   "source": [
    "For the specification values we know the attributes we need, but we do not have a list of records or a table object. The following steps must be performed:\n",
    "1. Create a single flat list of all linked specification records. Use a `set` as the intermediary container to only include unique records.\n",
    "2. Extract the table name from one of the specification records and create a `specification_table` object.\n",
    "3. Use the `specification_table` object to bulk fetch the data."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "25a83acc-4c53-461c-b0c7-b17c0d1159b7",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-05-10T23:01:50.721920Z",
     "iopub.status.busy": "2022-05-10T23:01:50.721920Z",
     "iopub.status.idle": "2022-05-10T23:01:51.440672Z",
     "shell.execute_reply": "2022-05-10T23:01:51.440672Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Fetched 4 attributes across 1 records\n"
     ]
    }
   ],
   "source": [
    "# Step 1: Generate a single list of unique linked specification records\n",
    "spec_records = set()\n",
    "for r in records_to_process:\n",
    "    spec_records.update(r.links[SPEC_LINK_GROUP_NAME])\n",
    "spec_records = list(spec_records)\n",
    "    \n",
    "# Step 2: Get the specification table object\n",
    "specification_table_name = spec_records[0].table_name\n",
    "specification_table = db.get_table(specification_table_name)\n",
    "\n",
    "# Step 3: Bulk fetch the data\n",
    "specification_data_attributes = list(COMPARISON_ATTRIBUTES.keys())\n",
    "specification_table.bulk_fetch(records=spec_records, attributes=specification_data_attributes)\n",
    "print(f\"Fetched {len(specification_data_attributes)} attributes across {len(spec_records)} records\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e048286a-a915-4c7a-9a08-916ad8397285",
   "metadata": {},
   "source": [
    "### Comparison logic"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "dfe00a35-3812-4057-a7e5-3386eeb29cb1",
   "metadata": {},
   "source": [
    "Next, write a function that compares the test data attribute and the specification attribute and returns the result as a string. This function includes an initial check to ensure values exist for both attributes. If either attribute does not have a value, return `None`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "1f09e5f0-deca-4ad9-82bf-e602967d0987",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-05-10T23:01:51.450669Z",
     "iopub.status.busy": "2022-05-10T23:01:51.450669Z",
     "iopub.status.idle": "2022-05-10T23:01:51.460662Z",
     "shell.execute_reply": "2022-05-10T23:01:51.460662Z"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "from typing import Optional\n",
    "\n",
    "def compare_test_to_spec(test_attribute: mpy.AttributePoint, spec_attribute: mpy.AttributePoint) -> Optional[str]:\n",
    "    if test_attribute.is_empty() or spec_attribute.is_empty():\n",
    "        return None\n",
    "    test_value = test_attribute.value\n",
    "    low_spec_value = spec_attribute.value['low'] or float(\"-inf\")\n",
    "    high_spec_value = spec_attribute.value['high'] or float(\"inf\")\n",
    "    \n",
    "    if low_spec_value <= test_value <= high_spec_value:\n",
    "        return \"Test meets specification\"\n",
    "    else:\n",
    "        return \"Test does not meet specification\""
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b883e7cf-1655-442d-955d-c28d036db26f",
   "metadata": {},
   "source": [
    "### Compare the data"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "df433b79-9e8c-4600-a3b4-4d1c5b824dfa",
   "metadata": {},
   "source": [
    "Finally, iterate over all records in the `records_to_process` list and all attributes in the `COMPARISON_ATTRIBUTES` constant. For each combination of record and attribute, call the function defined above and store the result in the *Specification Status* meta-attribute. The comparison is skipped if the meta-attribute is already populated."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "a424e5bc-4c7a-49c9-a088-3e91d0c1f683",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-05-10T23:01:51.460662Z",
     "iopub.status.busy": "2022-05-10T23:01:51.460662Z",
     "iopub.status.idle": "2022-05-10T23:01:51.470662Z",
     "shell.execute_reply": "2022-05-10T23:01:51.470662Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "MTS-615766\n",
      " - 0.02% Offset Yield Stress result: Test meets specification\n",
      " - 0.2% Offset Yield Stress skipped: <No data>\n",
      " - Young's Modulus (11-axis) result: Test does not meet specification\n",
      " - Ultimate Tensile Strength skipped: <No data>\n",
      "MTS-615726\n",
      " - 0.02% Offset Yield Stress result: Test does not meet specification\n",
      " - 0.2% Offset Yield Stress skipped: <No data>\n",
      " - Young's Modulus (11-axis) result: Test meets specification\n",
      " - Ultimate Tensile Strength skipped: <No data>\n",
      "MTS-615746\n",
      " - 0.02% Offset Yield Stress result: Test meets specification\n",
      " - 0.2% Offset Yield Stress skipped: <No data>\n",
      " - Young's Modulus (11-axis) result: Test meets specification\n",
      " - Ultimate Tensile Strength skipped: <No data>\n",
      "MTS-615756\n",
      " - 0.02% Offset Yield Stress result: Test meets specification\n",
      " - 0.2% Offset Yield Stress skipped: <No data>\n",
      " - Young's Modulus (11-axis) result: Test meets specification\n",
      " - Ultimate Tensile Strength skipped: <No data>\n",
      "MTS-615736\n",
      " - 0.02% Offset Yield Stress result: Test does not meet specification\n",
      " - 0.2% Offset Yield Stress skipped: <No data>\n",
      " - Young's Modulus (11-axis) result: Test meets specification\n",
      " - Ultimate Tensile Strength skipped: <No data>\n",
      "MTS-615776\n",
      " - 0.02% Offset Yield Stress result: Test meets specification\n",
      " - 0.2% Offset Yield Stress skipped: <No data>\n",
      " - Young's Modulus (11-axis) result: Test does not meet specification\n",
      " - Ultimate Tensile Strength skipped: <No data>\n"
     ]
    }
   ],
   "source": [
    "records_to_update = []\n",
    "\n",
    "for test_record in records_to_process:\n",
    "    test_specimen_id = test_record.attributes[SPECIMEN_ID_ATTRIBUTE].value\n",
    "    print(f\"{test_specimen_id}\")\n",
    "    \n",
    "    spec_record = next(iter(test_record.links[SPEC_LINK_GROUP_NAME]))\n",
    "    modified_attributes = []\n",
    "    for spec_attribute_name, test_attribute_name in COMPARISON_ATTRIBUTES.items():\n",
    "        test_attribute = test_record.attributes[test_attribute_name]\n",
    "        spec_status_meta_attribute = test_attribute.meta_attributes[SPEC_STATUS_META_ATTRIBUTE]  \n",
    "        if not spec_status_meta_attribute.is_empty():\n",
    "            print(f\" - {test_attribute_name} skipped: <Already populated>\")\n",
    "            continue\n",
    "        \n",
    "        spec_attribute = spec_record.attributes[spec_attribute_name]\n",
    "        status = compare_test_to_spec(test_attribute, spec_attribute)\n",
    "        if not status:\n",
    "            print(f\" - {test_attribute_name} skipped: <No data>\")\n",
    "            continue\n",
    "        \n",
    "        print(f\" - {test_attribute_name} result: {status}\")\n",
    "        spec_status_meta_attribute.value = status\n",
    "        modified_attributes.append(spec_status_meta_attribute)\n",
    "    if modified_attributes:\n",
    "        test_record.set_attributes(modified_attributes)\n",
    "        records_to_update.append(test_record)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "35489a3d-ac6a-4b54-ae91-c16af2df5ce8",
   "metadata": {},
   "source": [
    "## Push the results to Granta MI"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "6f865633-ba15-4ac6-9a33-409844af8596",
   "metadata": {},
   "source": [
    "The final step is to update the processed records in Granta MI. Once the cell below has completed, click the link to view the results in MI Viewer."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "a84371ed-e5b3-4615-ad0e-18c6d2c9529f",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-05-10T23:01:51.470662Z",
     "iopub.status.busy": "2022-05-10T23:01:51.470662Z",
     "iopub.status.idle": "2022-05-10T23:01:56.716360Z",
     "shell.execute_reply": "2022-05-10T23:01:56.716360Z"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "6 records modified. Links to the MI Viewer datasheets are provided below.\n",
      "MTS-615766: http://localhost/mi/datasheet.aspx?dbKey=MI_Training&recordHistoryGuid=fdd81e11-bcdd-4ed3-bf37-6ed12f7e2162\n",
      "MTS-615726: http://localhost/mi/datasheet.aspx?dbKey=MI_Training&recordHistoryGuid=6bcb5814-9ff5-4df1-8c92-984474d4ca74\n",
      "MTS-615746: http://localhost/mi/datasheet.aspx?dbKey=MI_Training&recordHistoryGuid=c0130467-8847-4e22-aab2-d5ca2b6308fd\n",
      "MTS-615756: http://localhost/mi/datasheet.aspx?dbKey=MI_Training&recordHistoryGuid=d8cf380b-b48e-43b2-be5b-d150415f3691\n",
      "MTS-615736: http://localhost/mi/datasheet.aspx?dbKey=MI_Training&recordHistoryGuid=d2d7b359-49d4-4028-b75c-1a79ccb56892\n",
      "MTS-615776: http://localhost/mi/datasheet.aspx?dbKey=MI_Training&recordHistoryGuid=d5c2f875-7822-44dc-88b3-ffdf22f7a60f\n"
     ]
    }
   ],
   "source": [
    "if records_to_update:\n",
    "    modified_records = s.update(records_to_update)\n",
    "    print(f\"{len(modified_records)} records modified. Links to the MI Viewer datasheets are provided below.\")\n",
    "    for modified_record in modified_records:\n",
    "        print(f\"{modified_record.attributes[SPECIMEN_ID_ATTRIBUTE].value}\"\n",
    "              f\": {modified_record.viewer_url}\")\n",
    "else:\n",
    "    print(\"No records modified\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "74ccc4ee-c289-4845-8fa9-f770367752bd",
   "metadata": {},
   "source": [
    "## Clean up the database"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4ad15aed-8e86-4af0-9da1-d7d9353f213f",
   "metadata": {},
   "source": [
    "Uncomment the bottom line and run this cell to revert the changes made in this script. This is useful if you wish to run the script again."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "0583d6a6-ac0b-426c-ae7c-9abc44eb3168",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-05-10T23:01:56.716360Z",
     "iopub.status.busy": "2022-05-10T23:01:56.716360Z",
     "iopub.status.idle": "2022-05-10T23:01:56.726362Z",
     "shell.execute_reply": "2022-05-10T23:01:56.726362Z"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "for record in records_to_process:\n",
    "    for test_attribute in COMPARISON_ATTRIBUTES.values():\n",
    "        spec_attr = record.attributes[test_attribute].meta_attributes[SPEC_STATUS_META_ATTRIBUTE]\n",
    "        record.clear_attributes([spec_attr])\n",
    "# s.update(records_to_process)"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.10"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
